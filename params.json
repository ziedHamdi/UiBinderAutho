{"name":"UiBinderAutho","tagline":"GWT UiBinder authorization code : how is it thought, and what is  ready to use?","body":"### Welcome to UiBinderAutho the automatic part of the UiBinderAuth project.\r\nThis project is a concrete implementation that uses the low level feature added by [UiBinderAuth](https://github.com/ziedHamdi/UiBinderAuth). While the [UiBinderAuth](https://github.com/ziedHamdi/UiBinderAuth) is a fork of the GWT UiBinder with added abilities, this project is a base framework to use that added code interception feature.\r\n\r\nNote: at the current state, the API and the \"test classes\" are mixed together because this project is aimed to be a demo. You can however reuse a lot of classes and interfaces in this code. In any case you'll be obliged to download the sources and adjust the code for your needs. So consider it as a scaffold project for now\r\n\r\nThe main classes you should look at are the following:\r\n```\r\n ProfileSpecificWidgetCreator which contains the logic on how to change the look of any widget\r\n fr.onevu.auth.server.auth.Profile you'll have to change this server side class that specifies the behavior of your widgets (this is typically a check of the connected profile, then a database reading of the settings associated to the profile roles)\r\n /Auth/war/profile.jsp this file uses the answer of the server class Profile to load the settings into the page. You must do a <%@include file=\"profile.jsp\" %> in your module html file to be able to grab the info from the server.\r\n```\r\n\r\nThis code is the key to understand the initialization process, it's the Module startup code\r\n\r\n```\r\n\tpublic void onModuleLoad() {\r\n\t\tRootPanel profilePanel = RootPanel.get(\"profile\");\r\n\t\tif (profilePanel == null)\r\n\t\t\treturn;\r\n\r\n\t\tString rulesJson = profilePanel.getElement().getInnerHTML().trim();\r\n\t\tif (rulesJson == null || 0 == rulesJson.length())\r\n\t\t\treturn;\r\n\r\n\t\tProfileWidgetJsonSerializer jsonSerializer = new ProfileWidgetJsonSerializer();\r\n\r\n//here the rules get injected to the client : you can start using UiBinder from now\t\t        ProfileSpecificWidgetCreator.setProfileWidgetRules(jsonSerializer.deserializeFromJson(rulesJson));\r\n```\r\n\r\n\r\n###Deeper reading\r\n\r\nGWT UiBinder authorization layer : a proxy that give you control over the creation of each widget\r\n\r\n(this project was first shared on google code : https://code.google.com/p/ui-binder-factory-proxy/)\r\n\r\nWhat is it for? UiBinder? is a great way to isolate ui design code and ui logic. It unfortunately doesn't permit to declare authorization rules.\r\n\r\nThat's the purpose of this library that is a fork of GWT UiBinder?: you can decide to intercept the creation of widgets declared in UiBinder? to change their look, hide them, add handlers, etc...\r\n\r\nYou can also cache Widget instances for later reuse.\r\n\r\nWhy is it needed? UiBinder? describes well how fields have to display, but it doesn't include any profile mechanism.\r\n\r\nWith this library you can put all the widgets of all the possible scenarios in a screen, and depending on the connected profile, you can hide some widgets, use personalized styles, add handlers, listen to event bus, and more.\r\n\r\nThe current version doesn't support holding the created widget references. So currently, if a new user connects (or an application wide information changes), you need to reload the page. It's okay since if a person disconnects it's a big enough operation to reload the page.\r\n\r\nBut in future versions, a Widget pool cache will be provided. This will allow dynamic changes to be reflected on widgets: for example when the person will look at a profile page (let's say in a social network), all widgets could change look because the Place specifies it's looking at a profile.\r\n\r\nWhat does it do? This library permits to :\r\n\r\ncontrol widgets at creation time (the xml file and the field name are passed as arguments) modify the declarations stated in UiBinder? xml files (at creation + on event bus events) add handlers to widgets (at creation + on event bus events) not intrusive to your existing architecture: plugged from the outside This library intercepts the request to create new widgets, it has detailed information about the widget (UiBinder? file + field name). It may therefore be used to recycle widgets in a pool\r\n\r\nWhat does it not do? Since problems can be solved in many ways, this library focuses on the widget creation subject only. It doesn't provide any services after creation like checking the states of the widget tree. That can be done in different manners, and we prefer not to choose one on your behalf\r\n\r\nThe objective of the library being non intrusive is a key concept. Therefore, a different project will propose a way to cache widgets and another one will propose to register handlers to recycle widgets and handle them during their life cycle.\r\n\r\nWhere will it evolve The UiBinder? generates too many code that is hard to debug since it is text that has to be compiled. This library will gradually replace parts of the generated \"hard coded text\" by extensible calls to compiled code (that can be separately unit tested).\r\n\r\nFor now it is done only for after initialization is done : the init() method.\r\n\r\nBut all what happens between can gradually be moved to compiled code: attached event handles, styleName css setting. Also direct accessor calls like can be proxied to be interceptable. The generated code will do something like:\r\n\r\nif( proxy.canCall( fieldName ) ) field.setText();\r\n\r\nWhere should I start? clone this library and get started: https://github.com/ziedHamdi/UiBinderAutho/blob/master/README.md","google":"UiBinderAutho","note":"Don't delete this file! It's used internally to help with page regeneration."}